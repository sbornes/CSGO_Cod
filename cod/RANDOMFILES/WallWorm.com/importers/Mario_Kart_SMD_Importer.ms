/*--======================================--*\
SOURCE - SMD Importer

(Jan13/2013)
Original importer written by Corey Nguyen.
Donated to Wall Worm by Corey Nguyen
Date: January 13, 2013

http://www.facebook.com/corey.van.nguyen
http://www.youtube.com/user/mariokart64n

Rewritten, optimized and appended to by Shawn Olson and Orvid King for use in Wall Worm.
http://dev.wallworm.com

QC Parsing and Importing by Shawn Olson. Added on 2-3-2013 .

Animation Importing added on 4-23-2013

VTA Importing adding in Dec 2014

Now requires the FGD parser functions to be included.

*/--======================================--\*

if (::wallworm_installation_path == undefined) then (
	::wallworm_installation_path = pathConfig.removePathLeaf (pathConfig.removePathLeaf (getFilenamePath (getThisScriptFilename())))
)

fileIn (::wallworm_installation_path + "/WallWorm.com/WallWormModelTools/ww_structs.ms")
fileIn (::wallworm_installation_path + "/WallWorm.com/custom_attributes/bodygroups.ms")
fileIn (::wallworm_installation_path + "/WallWorm.com/common/flexfuncs.ms")
fileIn (::wallworm_installation_path + "/WallWorm.com/common/performanceCounters.ms")
fileIn (::wallworm_installation_path + "/WallWorm.com/common/bone_funcs.ms")

struct tmplod (
	val = 1,
	replacemodels = #(),
	qciincludes = #()
)
struct model (
	filename,
	flexfile = #()
)
struct flexinfo (
	name,
	labl,
	frame,
	isDefault = false
)
struct flexstruct (
	flexfile,
	flexes = #()
)

function wallworm_import_smd fsource vtanode:undefined frameinfo:undefined condenseMesh:true materialp:undefined removeUnweightedBonesFromSkin:false YUp:false rotateModel:false rotationAmount:90 offsets:[0, 0, 0] zeroRotations:false xf:false uniqueNames:false collapseMeshes:false staticprop:true autoQuadrifyStaticprop:true isSequence:false timeOffset:0 addToTimeline:false skipAnimation:false nodePrefix:"" deepSearchMaterials:true = (
	::wallworm_performanceCounter_reset()

	::wallworm_performanceCounter_start #smdImporter #wallworm_import_smd
	set coordsys world
	max create mode
	local buildMsh = (NOT isSequence)
	local buildSkn = (NOT isSequence AND staticprop != true)
	local buildSkl = true
	local msh = undefined
	local meshes = #()
	local newBones = #()
	--local rootRotationAnglesStore = undefined
	local rootOffsetPositionStore = undefined

	if (fsource != undefined) AND ((doesFileExist fsource) == true) then (
		local f = MemStreamMgr.openFile fsource

		function parseBlock fstream = (
			local string_array = #()
			local tag = fstream.readLine()
			while tag != "end" AND fstream.eos() != true do (
				local tag2 = trimLeft tag
				free tag

				--lines to ignore until support for these features are added (to speed gneeration up)		
				if tag2 != "" AND NOT matchPattern tag2 pattern:"//*" AND NOT matchPattern tag2 pattern:"*File generated by*" then (
					append string_array tag2
				) else (
					free tag2
				)
				tag = fstream.readLine()
			)
			free tag
			string_array
		)

		-- realtive to world positions
		function relativeToWorld obj obj2 idx = (
			local pos = obj.matrix[idx]
			if pos == undefined then (
				pos = Matrix3 1
				obj.matrix[idx] = pos
			)
			par = obj2.parent[idx]
			if par != undefined AND par != 0 then (
				while par != undefined AND par != 0 do (
					if obj.matrix[par] != undefined then (
						pos *= obj.matrix[par]
					)
					par = obj2.parent[par]
				)
			)
			pos
		)

		while (toLower (trimLeft(trimRight(f.readLine())))) != "version 1" do (
			--print (f.readLine())
		)

		struct smd_format (header, nodes, skeleton, bones, boneIDMap, boneArray, animations)
		struct smd_header (version)
		struct smd_nodes (index, name, parent)
		struct smd_skeleton (frame, bone)
		struct smd_bone (index, matrix)

		struct smd_vertex (parent, position, normal, texture, count, boneid, weight, faces)
		struct vta_vertex(index, position, normal)

		local vertPositions = #()
		local faceIDs = #()
		local matIDArray = #()
		local vertUVs = #()
		local vertNorms = #()
		local meshDataArray = #()
		local weightArray = #()
		local smdArray
		smdArray = (smd_format header:#() nodes:#() skeleton:#() bones:#() boneIDMap:#() boneArray:#() animations:#())
		smdArray.header = (smd_header version:("version 1"))
		smdArray.nodes = (smd_nodes index:#() name:#() parent:#())
		smdArray.skeleton = (smd_skeleton frame:#() bone:#())
		local highestBoneCount = 1
		face_lookup = #()
		local weightedBones = #{}
		/*
		Will add this block back to the code when updated to ignore opening comments.	
		*/
		--if smdArray.header.version == "version 1" then (

		::wallworm_performanceCounter_start #smdImporter #'wallworm_import_smd-Core Parse'
		while f.eos() != true do (
			local smd_element = f.readLine()

			smd_element = trimLeft smd_element
			smd_element = trimRight smd_element
			smd_element = substituteString smd_element "\t" " "
			smd_element = substituteString smd_element "  " " "

			--lines to ignore until support for these features are added (to speed gneeration up)		
			if (smd_element == undefined OR smd_element == "" OR (((substring smd_element 1 2) == "//") OR matchPattern smd_element pattern:"*File generated by the Wall Worm*")) then (
				--oops... probably a comment
				--print ("Skipping this line: "+ smd_element)
			) else (
				strArray = parseblock f
				case smd_element of (
					"nodes":(
						::wallworm_performanceCounter_start #smdImporter #'wallworm_import_smd-Core Parse-nodes'
						for i = 1 to strArray.count do (
							/*		local theString = (strArray[i] as stringstream) as string
							substituteString theString "\t" " "
							while (matchpattern theString pattern:"*  *") do (
								theString = substituteString theString "  " " "
							)
							values = filterString theString " "

							if values.count == 3 then (
								smdArray.nodes.index[i] = values[1]
								smdArray.nodes.name[i] = substituteString values[1] "\"" ""
								smdArray.nodes.parent[i] = values[3]
							)*/

							smdArray.nodes.index[i] = (readDelimitedString (strArray[i] as StringStream) "\"")
							smdArray.nodes.name[i] = (strArray[i] as StringStream)
							skipToString (smdArray.nodes.name[i] as StringStream) "\""
							smdArray.nodes.name[i] = readDelimitedString (smdArray.nodes.name[i] as StringStream) "\""
							smdArray.nodes.parent[i] = (strArray[i] as StringStream)
							skipToString (smdArray.nodes.parent[i] as StringStream) "\""
							skipToString (smdArray.nodes.parent[i] as StringStream) "\""
							smdArray.nodes.parent[i] = (execute (readDelimitedString (smdArray.nodes.parent[i] as StringStream) "")) + 1
						)
						::wallworm_performanceCounter_stop #smdImporter #'wallworm_import_smd-Core Parse-nodes'
					)
					"skeleton": (
						::wallworm_performanceCounter_start #smdImporter #'wallworm_import_smd-Core Parse-skeleton'
						local cnt = 1
						while cnt <= strArray.count do (
							local delimited = filterString strArray[cnt] " "
							cnt += 1
							frame_index = (delimited[2] as Integer) + 1
							free delimited[1]
							free delimited[2]
							free delimited

							local isTime = false
							smdArray.skeleton.frame[frame_index] = frame_index
							smdArray.skeleton.frame[frame_index] = (smd_bone index:#() matrix:#())
							do (
								if strArray[cnt] != undefined then (
									delimited = filterString strArray[cnt] " "
									if delimited[1] != "time" then (
										bone_index = (delimited[1] as Integer) + 1
										free delimited[1]

										rootRotationAngles = EulerAngles (radToDeg (delimited[5] as Float)) (radToDeg (delimited[6] as Float)) (radToDeg (delimited[7] as Float))
										free delimited[5]
										free delimited[6]
										free delimited[7]

										if rootRotationAnglesStore == undefined then (
											if zeroRotations == true then (
												rootRotationAngles = EulerAngles 0 0 0
											)

											rootRotationAnglesStore = rootRotationAngles
										)

										bone_matrix = rootRotationAngles as Matrix3
										bone_matrix.row4 = [delimited[2] as Float, delimited[3] as Float, delimited[4] as Float]
										if offsets != undefined then (
											bone_matrix.row4 += offsets
										)
										free delimited[2]
										free delimited[3]
										free delimited[4]
										smdArray.skeleton.frame[frame_index].index[bone_index] = bone_index
										smdArray.skeleton.frame[frame_index].matrix[bone_index] = bone_matrix
										--smdArray.skeleton.frame[frame_index].rangle[bone_index]=rootRotationAngles	

										cnt += 1
									) else (
										isTime = true
										free delimited[1]
										frame_index = (delimited[2] as Integer) + 1
										free delimited[2]
									)
									free delimited
								) else (
									cnt += 1
								)
							) while NOT isTime AND cnt <= strArray.count
						)
						::wallworm_performanceCounter_stop #smdImporter #'wallworm_import_smd-Core Parse-skeleton'
					)
					"vertexanimation":(
						::wallworm_performanceCounter_start #smdImporter #'wallworm_import_smd-Core Parse-vertex animation'
						cnt = 1
						while cnt <= strArray.count do (
							delimited = filterString strArray[cnt] " "
							cnt += 1
							frame_index = (delimited[2] as Integer) + 1
							smdArray.skeleton.frame[frame_index] = frame_index
							smdArray.animations[frame_index] = #()
							do (
								delimited = filterString strArray[cnt] " "
								if delimited[1] != "time" then (
									local vert_index = (delimited[1] as Integer) + 1
									local pos = [(delimited[2] as Float), (delimited[3] as Float), (delimited[4] as Float)]
									if offsets != undefined then (
										pos += offsets

									)
									local norm = [(delimited[5] as Float), (delimited[6] as Float), (delimited[7] as Float)]

									local vert = vta_vertex index:vert_index position:pos normal:norm
									smdArray.animations[frame_index][vert_index] = vert
									--smdArray.skeleton.frame[frame_index].rangle[bone_index]=rootRotationAngles	

									cnt += 1
								)else(
									frame_index = (delimited[2] as Integer) + 1
								)
							) while delimited[1] != "time" AND cnt <= strArray.count
						)
						::wallworm_performanceCounter_stop #smdImporter #'wallworm_import_smd-Core Parse-vertex animation'
					)
					"triangles":(
						::wallworm_performanceCounter_start #smdImporter #'wallworm_import_smd-Core Parse-triangles'
						cnt = 0
						local mat_id = 0
						local faceID = 1
						local theMatNames = #()
						local vertCount = 0

						struct meshdatastruct (
							weightArray = #(),
							vertPositions = #(),
							vertNorms = #(),
							vertUVs = #(),
							faceIDs = #(),
							matIDArray = #(),
							vertIndexes = #(),
							vertCount = 0,
							faceID = 1
						)

						local theDataObjMain

						if condenseMesh == true then (
							theDataObjMain = meshdatastruct()
							append meshDataArray theDataObjMain
						)

						for i = 1 to (strArray.count / 4) do (
							::wallworm_performanceCounter_start #smdImporter #'wallworm_import_smd-Core Parse-triangles-Main Loop Body'
							cnt = ((i - 1) * 4) + 1
							tex_name = strArray[cnt]
							--free strArray[cnt]
							cnt += 1

							mat_id = findItem theMatNames tex_name
							if mat_id == 0 then (
								append theMatNames tex_name
								mat_id = theMatNames.count
								theMatNames[mat_id] = tex_name
							)
							local theDataObj

							if condenseMesh == true then (
								theDataObj = theDataObjMain
							)

							local vertIndexes = #()
							local realBoneID
							-- Because the GC is absolutely brutal in this tight of code, we do what
							-- we can to prevent the GC from being called, and that means freeing what
							-- we can manually.
							::wallworm_performanceCounter_start #smdImporter #'wallworm_import_smd-Core Parse-triangles-Main Loop Body-Inner Loop'
							for x = 1 to 3 do (
								delimited = filterString strArray[cnt] " "
								free strArray[cnt]
								cnt += 1
								if x == 1 then (
									boneid = delimited[1] as Integer

									if boneid == undefined then (
										boneid = 0
									)
									realBoneID = boneid + 1
									if condenseMesh == false then (
										theDataObj = meshDataArray[RealBoneID]
										if theDataObj == undefined then (
											meshDataArray[RealBoneId] = meshdatastruct()
											theDataObj = meshDataArray[RealBoneID]
										)
									)

									append theDataObj.matIDArray mat_id
								)

								free delimited[1]

								theDataObj.vertCount += 1

								append vertIndexes theDataObj.vertCount

								if delimited.count >= 9 then (
									::wallworm_performanceCounter_start #smdImporter #'wallworm_import_smd-Core Parse-triangles-Main Loop Body-Inner Loop-Position, Normal, Texture'

									local x, y, z
									x = delimited[2] as Float
									y = delimited[3] as Float
									z = delimited[4] as Float

									if x == undefined then x = 0.0
									if y == undefined then y = 0.0
									if z == undefined then z = 0.0
									position = [x, y, z]

									if offsets != undefined then (
										position += offsets
									)

									x = delimited[5] as Float
									y = delimited[6] as Float
									z = delimited[7] as Float
									if x == undefined then x = 0.0
									if y == undefined then y = 0.0
									if z == undefined then z = 0.0
									normal = [x, y, z]

									x = delimited[8] as Float
									y = delimited[9] as Float

									if x == undefined then x = 0.0
									if y == undefined then y = 0.0
									texture = [x, y, 0]

									free delimited[2]
									free delimited[3]
									free delimited[4]
									free delimited[5]
									free delimited[6]
									free delimited[7]
									free delimited[8]
									free delimited[9]
									::wallworm_performanceCounter_stop #smdImporter #'wallworm_import_smd-Core Parse-triangles-Main Loop Body-Inner Loop-Position, Normal, Texture'

									local skipBoneCount = false
									if delimited[10] != undefined then (
										bone_id_count = delimited[10] as Integer
										free delimited[10]
									) else (
										skipBoneCount = true
										bone_id_count = 1
										weightedBones[realBoneID] = true

									)
									id_index = 11
									local bi = #()
									local bw = #()

									local rootBoneIndex = undefined

									if skipBoneCount == false then (
										local wts = 0.0
										for y = 1 to bone_id_count do (
											local thisBoneID = (delimited[id_index] as Integer) + 1
											free delimited[id_index]
											id_index += 1

											if thisBoneID == realBoneID then (
												rootBoneIndex = y
											) else (
												bw[y] = (delimited[id_index] as Float)
												bi[y] = (thisBoneID)
												weightedBones[thisBoneID] = true
												wts += bw[y]
											)
											free delimited[id_index]
											id_index += 1

										)

										if wts < 1.0 then (
											local diff = 1.0 - wts

											if rootBoneIndex != undefined then (
												weightedBones[realBoneID] = true
												if bw[rootBoneIndex] == undefined then (
													bw[rootBoneIndex] = diff
												) else (
													bw[rootBoneIndex] += diff
												)

												if bi[rootBoneIndex] == undefined then (
													bi[rootBoneIndex] = realBoneID
												)

											) else (
												bone_id_count += 1
												bi[bone_id_count] = realBoneID
												bw[bone_id_count] = diff
											)
										)

										if bone_id_count > highestBoneCount then (
											highestBoneCount = bone_id_count
										)

									) else (
										bi[1] = realBoneID
										bw[1] = 1
									)

									append theDataObj.weightArray (#(bi, bw))

									--find = smdArray.triangles.geometry[mat_id].position.count
									--append face_lookup[mat_id] str
									--append currentGeometry.verts vertCount
									--append currentGeometry.parent realBoneID
									append theDataObj.vertPositions position
									append theDataObj.vertNorms normal
									append theDataObj.vertUVs texture
									--append currentGeometry.count bone_id_count
									--append currentGeometry.boneid bi
									--append currentGeometry.weight bw

								)

								free delimited
							)
							::wallworm_performanceCounter_stop #smdImporter #'wallworm_import_smd-Core Parse-triangles-Main Loop Body-Inner Loop'

							append theDataObj.faceIDs [vertIndexes[1], vertIndexes[2], vertIndexes[3]]
							theDataObj.faceID += 1

							::wallworm_performanceCounter_stop #smdImporter #'wallworm_import_smd-Core Parse-triangles-Main Loop Body'
						)

						::wallworm_performanceCounter_stop #smdImporter #'wallworm_import_smd-Core Parse-triangles'
					)
				)
			)
		)
		::wallworm_performanceCounter_stop #smdImporter #'wallworm_import_smd-Core Parse'

		boneArray = #()
		::wallworm_performanceCounter_start #smdImporter #'wallworm_import_smd-Build Skeleton'
		if staticprop != true AND smdArray.skeleton.frame[1] != undefined AND smdArray.skeleton.frame[1] != 1 then (
			bone_count = smdArray.skeleton.frame[1].matrix.count
			global wallworm_smd_import_time
			if wallworm_smd_import_time != undefined AND staticprop != true AND isSequence == true then (
				wallworm_smd_import_time += smdArray.skeleton.frame.count
			)

			for i = 1 to bone_count do (
				for framenum = 1 to smdArray.skeleton.frame.count do (
					bone_transform = relativetoworld smdArray.skeleton.frame[framenum] smdArray.nodes i

					if bone_transform == undefined then (
						bone_transform = Matrix3 1
					)

					bone_ext = bone_transform.row4 + [0, 0, 4]
					find = findItem smdArray.nodes.parent i
					if find != 0 then (
						bone_ext = relativetoworld smdArray.skeleton.frame[framenum] smdArray.nodes find
						bone_ext = bone_ext.row4
					)

					local bb
					if smdArray.nodes.name[i] != undefined then (
						smdArray.nodes.name[i] = smdArray.nodes.name[i] as String

						--See if this node already exists in the scene. This is so that Sequence SMDs can re-use existing bones from Reference SMDs.
						--There is a danger that another model was imported that might have a node with and identical name... which could create problems. This is most
						--likely with the VMF importer functions that import models from props en mass.
						bb = getNodeByName (smdArray.nodes.name[i])

					)

					if NOT isValidNode bb then (
						--Since the Bone wasn't found in the scene, create it.
						bb = (BoneSys.createBone bone_transform.row4 bone_ext [0, 0, 1])
						bb.showLinks = true
						bb.showLinksOnly = off
						bone_size = 1
						bb.width = bone_size
						bb.height = bone_size
						bb.transform = bone_transform
						bb.length = 3
						bb.boneEnable = true
						append newBones bb
						custAttributes.add bb ::wallworm_bone_CA
						if smdArray.nodes.name[i] != undefined then (
							smdArray.nodes.name[i] = smdArray.nodes.name[i] as String
							if uniqueNames == true then (
								--Make the node name unique---which is important if there are nodes in the scene with this same name already
								smdArray.nodes.name[i] = (uniqueName (smdArray.nodes.name[i]))
							)
							bb.name = smdArray.nodes.name[i]
						)
					) else (
						if NOT skipAnimation then (
							--For Sequence SMDs, this will set the keyframes and animate the model.
							with animate on (
								at time (framenum + timeOffset) bb.transform = bone_transform
								--find out why bones not listed in the SMD are positioned wrong.
								smdArray.nodes.name[i] = smdArray.nodes.name[i] as String
							)
						)
					)

					if isValidNode bb then (
						appendIfUnique boneArray bb

						if NOT isValidNode smdArray.boneArray[i] then (
							smdArray.boneArray[i] = bb
						)
					)
				)
			)

			if isSequence == false then (
				--Do all the Parenting. Shouldn't be done with sequences... as they should already have been set up with the Reference.
				for i = 1 to bone_count do (
					par = smdArray.nodes.parent[i]

					if par != undefined AND par != 0 AND (boneArray[i].parent == undefined AND boneArray[i].parent != boneArray[par] AND NOT refs.dependencyLoopTest boneArray[i] boneArray[par]) then (
						boneArray[i].parent = boneArray[par]

					) else (
						if zeroRotations == true AND (par == undefined OR par == 0) then (
							--Align Unparented Bones to the World if zeroRotations set to true
							boneArray[i].transform = Matrix3 1
						)
					)
				)
			)

			if yUp == true then (
				--Rotate the unparented bones for SMDs created in Maya
				toolMode.coordsys #world
				toolMode.transformCenter()
				for i = 1 to bone_count do (
					if smdArray.nodes.parent[i] == 0 then (
						in coordsys world (
							rotate boneArray[i] (AngleAxis 90 [1, 0, 0])
							local cp = boneArray[i].pos
							boneArray[i].pos = [cp.x, (cp.z * -1), cp.y]
						)
					)
				)
			)

			if staticprop == true then (
				--no need for any stinking bones
				delete boneArray
				boneArray = #()
			)

			if boneArray.count > 0 then (
				::wwmtImportsLayersBones = (ww_CreateLayer "Imported Bones" forceFunc:true).addNode
				for bb in boneArray do (
					::wwmtImportsLayersBones bb
				)
			)

		)
		::wallworm_performanceCounter_stop #smdImporter #'wallworm_import_smd-Build Skeleton'

		if ::wallworm_debug != undefined AND ::wallworm_debug == true then (
			global wallworm_smdArrays
			if wallworm_smdArrays == undefined then (
				wallworm_smdArrays = #()
			)
			append wallworm_smdArrays smdArray
		)

		::wallworm_performanceCounter_start #smdImporter #'wallworm_import_smd-Build VTA Node'
		if NOT isValidNode vtanode AND buildMsh == true AND NOT isSequence then (
			local fsourcepath = undefined
			if deepSearchMaterials then (
				fsourcepath = (getFileNamePath (pathConfig.convertPathToAbsolute fsource))
			)
			local extraRootPaths = undefined
			if materialp != undefined then (
				extraRootPaths = #(materialp)
			)
			local num_mats = 0
			if theMatNames != undefined then (
				num_mats = theMatNames.count
				local mat = MultiMaterial numsubs:num_mats
				mat.numsubs = num_mats
				--meditMaterials[1] = mat

				local totalCount = 0

				for i = 1 to num_mats do (
					--basename = materialp +"/"+ (getFilenameFile theMatNames[i])
					basename = (getFilenameFile theMatNames[i])
					if basename != undefined then (
						local theVMT = wallworm_VMFIMPORT_getMaterial (basename) Color:undefined openLib:false matType:"model" extraPath:fsourcepath extraRootPaths:extraRootPaths overWriteName:basename
						if theVMT != undefined then (
							--theVMT.cdmaterials = materialp
							mat.materialList[i] = theVMT
							--mat.materialList[i] = wallworm_generateMaterialFromVMT theVMT matType:"model" extraPath:materialp 
							submat = mat.materialList[i]
						) else (
							submat = mat.materialList[i]
							submat.diffuseMap = Bitmaptexture fileName:basename
							submat.name = materialp + "/" + basename
						)
						mat.names[i] = basename						
					)


				)

			)

			for objData in meshDataArray WHERE objData != undefined do (
				msh = Mesh vertices:objData.vertPositions faces:objData.faceIDs materialIDs:objData.matIDArray
				vert_count = msh.numverts
				msh.numTVerts = vert_count
				buildTVFaces msh
				msh.displayByLayer = false
				msh.backfacecull = on
				msh.wirecolor = random (Color 0 0 0) (Color 255 255 255)
				msh.material = mat
				msh.name = uniqueName (getFileNameFile fsource)
				/*
				if smdArray.skeleton.frame[1].matrix[i] != undefined then (
					rootRotationAnglesStore = smdArray.skeleton.frame[1].matrix[i].rotationPart as EulerAngles
				) else (
					rootRotationAnglesStore = EulerAngles 0 0 0
				)
				setUserProp msh #ImportedSMDRotations (rootRotationAnglesStore as String)
				*/
				local vertUVs = objData.vertUVs
				local faceIDs = objData.faceIDs
				local vertNorms = objData.vertNorms

				for j = 1 to vertUVs.count do setTVert msh j vertUVs[j]
				for j = 1 to faceIDs.count do setTVFace msh j faceIDs[j]
				for j = 1 to vertNorms.count do setNormal msh j vertNorms[j]

				--EN.ConvertVertexSelection vertexSelection normalSelection

				if zeroRotations == true then (
					msh.pos = [0, 0, 0]
				)

				/*!TODO
				Simplify all rotation nonesense. There is a good chance that this can be simplified to look for either $staticprop and/or $upaxis and rotate the mesh accordingly. 
				*/

				if rotateModel == true then (
					in coordsys world rotate msh (AngleAxis (rotationAmount) [0, 0, 1]) -- x
				)

				if YUp == true then (
					in coordsys world rotate msh (AngleAxis 90 [1, 0, 0])
				)

				if xf == true then (
					resetXForm msh
				)

				update msh
				convertToPoly msh
				if staticprop == true AND buildSkn == false then (
					msh.weldThreshold = 0.1
					polyop.weldVertsByThreshold msh #{1..msh.numverts}
					if autoQuadrifyStaticprop == true AND PolyToolsModeling != undefined then (
						select msh
						max modify mode
						PolyToolsModeling.Quadrify false false
						max create mode
					)
				)

				if buildSkn == true AND boneArray.count > 0 then (
					skinMod = skin ()
					if hasProperty skinMod #enableDQ then (
						skinMod.enableDQ = off
					)

					skinMod.bone_Limit = 3
					skinMod.weightAllVertices = off
					--skinMod.bone_Limit = highestBoneCount
					skinMod.rigid_vertices = false

					select msh
					max modify mode
					modPanel.addModToSelection skinMod
					modPanel.setCurrentObject skinMod

					local boneNameIDInt = 1

					if (maxversion())[1] < 16000 then (
						boneNameIDInt = 0 --test for older versions of Max.
					)

					for x = 1 to bone_count do (
						if x != bone_count
						then (skinOps.addBone skinMod boneArray[x] 0)
						else (skinOps.addBone skinMod boneArray[x] 1)
					)

					--One more of the funky tie of the Max UI to skinops... you need to do this or the bones won't be registered in the skin. Slows things down a lot.
					max create mode
					max modify mode
					modPanel.setCurrentObject skinMod

					local skinOpsReplaceVertexWeights = skinOps.replaceVertexWeights
					local skinOpsSetVertexWeights = skinOps.setVertexWeights
					local skinOpssetInnerRadius = skinOps.setInnerRadius
					local skinOpssetOuterRadius = skinOps.setOuterRadius
					local skinOpssetBonePropRelative = skinOps.setBonePropRelative

					smdArray.boneIDMap = boneIDMap
					local weightArray = objData.weightArray
					for x = 1 to msh.numverts do (
						local wt = weightArray[x]
						local bi = wt[1]
						local bw = wt[2]

						if bw != undefined AND bi != undefined AND bw.count == bi.count then (
							skinOpsReplaceVertexWeights skinMod x bi bw
						)
					)
					/*
					skinMod.clearZeroLimit = 0.001
					skinops.removeZeroWeights skinMod */
					if removeUnweightedBonesFromSkin then (
						/*Do not insert any bones that are not in the list*/
						for removeID = bone_count to 1 by -1 do (
							if weightedBones[removeID] == false then (
								--format "Remove Bone %\n" removeID
								skinOps.removeBone skinMod removeID

								max create mode
								max modify mode
								modPanel.setCurrentObject skinMod
								/*skinops.invalidate skinMod 1
								skinOps.resetAllBones skinMod
								forcecompleteredraw()*/
							)
						)
					)
					skinMod.clearZeroLimit = 0.02
					skinOps.RemoveZeroWeights skinMod
				)
				append meshes msh
			)
		)
		::wallworm_performanceCounter_stop #smdImporter #'wallworm_import_smd-Build VTA Node'

		::wallworm_performanceCounter_start #smdImporter #'wallworm_import_smd-Build Animations'
		if smdArray.animations.count > 0 then (
			if NOT isValidNode vtanode then (
				vtanode = meshes[1]
			)
			local anim = smdArray.animations
			if NOT isValidNode vtanode then (
				local f1 = anim[1]
				local vertCount = f1.count

				for findex = 2 to anim.count do (
					local thisAnim = anim[findex]
					local thisCount = thisAnim.count
					if thisCount > vertCount then (
						vertCount = thisCount
						f1 = thisAnim
					)

				)

				local verts = #()
				local normals = #()

				for v in f1 do (
					append verts v.position
				)
				local faces = #()
				local lastFace = #()
				for vi = 1 to vertCount do (
					append lastFace vi

					if mod lastFace.count 3 == 0 then (
						append faces ([lastFace[1], lastFace[2], lastFace[3]])

						lastFace = #()
					)

				)

				vtanode = Mesh vertices:verts faces:faces
				update vtanode

				for vi = 1 to vertCount do (
					setNormal vtanode vi f1[vi].normal
				)

				append meshes vtanode

			)

			if isValidNode vtanode then (
				select vtanode
				local morph = Morpher()
				local animationCount = anim.count
				addModifier vtanode morph
				modPanel.setCurrentObject morph
				for f = 1 to animationCount do (
					if anim[f] != undefined then (
						local newState = at time 0 snapshot vtanode
						newState.name = ("Frame" + f as String)
						local animationRanges = anim[f]
						local animationRangeCount = animationRanges.count

						if animationRangeCount > vtanode.numverts then (
							animationRangeCount = vtanode.numverts
						)

						for vert in animationRanges WHERE vert != undefined do (
							if vert != undefined then (
								vertIndex = vert.index
								setvert newState vertIndex vert.position
								setNormal newState vertIndex vert.normal
							)
						)
						WM3_MC_BuildFromNode morph f newState
						hide newState
						if frameinfo != undefined AND frameinfo.flexes.count > 0 then (
							local foundFrame = false
							for fx in frameinfo.flexes while foundFrame == false do (
								if (fx.frame) == f then (
									WM3_MC_SetName morph f fx.name
									newState.name = fx.name
									foundFrame = true
								)
							)
						)
					)
				)
				/*addmodifier vtanode vtanode.modifiers[1]
				addmodifier vtanode vtanode.modifiers[3]

				--delete original modifiers
				deletemodifier vtanode vtanode.modifiers.count
				deletemodifier vtanode vtanode.modifiers.count*/

				wwmt_vta_keyframes vtanode
			)
		)
		::wallworm_performanceCounter_stop #smdImporter #'wallworm_import_smd-Build Animations'

		::wallworm_performanceCounter_start #smdImporter #'wallworm_import_smd-Static Prop and Cleanup'
		if staticprop == true then (
			delete boneArray
			boneArray = #()
			newBones = for bb in newBones WHERE isValidNode bb collect bb
			delete newBones
			newBones = #()
		)

		if addToTimeline == true AND NOT isValidNode vtanode then (
			sliderTime += smdArray.skeleton.frame.count
		)

		--)else(messagebox "Error\nSMD Not Compatible with this Script")
		print (fsource + " Imported")
		MemStreamMgr.close f
		::wallworm_performanceCounter_stop #smdImporter #'wallworm_import_smd-Static Prop and Cleanup'
	)

	if ::wallworm_debug == true then (
		if ::ww_smdarray == undefined then (
			::ww_smdarray = #()
		)
		append ::ww_smdarray (#(smdArray, meshes))
		--format "\n########\nMesh Count: %\nMeshes: %\nCollapse?: %\n" meshes.count meshes collapseMeshes		
	)

	if meshes.count > 1 AND (collapseMeshes == true OR staticprop == true) then (
		att = polyop.attach
		m = meshes[1]
		for i = 2 to meshes.count do (
			att m meshes[i]
		)
		meshes = #(m)
	)

	::wallworm_performanceCounter_stop #smdImporter #wallworm_import_smd
	::wallworm_performanceCounter_showData()
	#(meshes, newBones)
)

function wallworm_backpathlookup pth filename = (
	local upPaths = 0
	while matchPattern filename pattern:"*../*" AND substring filename 1 3 == "../" do (
		upPaths += 1
		filename = replace filename 1 3 ""
	)
	if upPaths > 0 then (
		for i = 1 to upPaths do (
			pth = pathConfig.removePathLeaf pth
		)
	)
	pth + "/" + filename
)

function wallworm_backpathlookup2 pth = (
	local upPaths = 0
	while matchPattern pth pattern:"*../*" AND substring pth 1 3 == "../" do (
		upPaths += 1
		pth = replace pth 1 3 ""
	)
	pth
)

function parseFlexFileData &texGstr &qc &thisModel closeAtEnd:true = (
	if texGstr != undefined then (
		local splitStr
		local theFlagLine
		local currentJiggleArray = undefined
		while texGstr.eos() == false AND texGstr.peekToken() != undefined do (
			texGstr.skipSpace()
			local texLine = texGstr.readLine()
			texLine = trimRight(trimLeft (texLine))
			texLine = substituteString texLine "\t" " "
			texLine = substituteString texLine "  " " "
			texLineArray = filterString texLine " "
			case of (
				(texLine == ""):(/*skip*/)
				(matchPattern texLine pattern:"*$include*"):(
					thisincludedqci = substituteString texLineArray[2] "\"" ""
					if doesFileExist thisincludedqci then (
						local theQCI = MemStreamMgr.openFile thisincludedqci
						parseFlexFileData &theQCI &qc &thisModel
					) else (
						local lookFor
						local hasFoundFile = false
						for pth in qc.paths while hasFoundFile == false do (
							lookfor = wallworm_backpathlookup pth thisincludedqci
							if doesFileExist (lookfor) then (
								local theQCI = MemStreamMgr.openFile lookfor
								parseFlexFileData &theQCI &qc &thisModel
								hasFoundFile = true
							)
						)
					)
				)
				default:(
					local texlinCount = texLineArray.count
					if texlinCount >= 3 then (
						local ft = toLower (texLineArray[1])

						local ftn = flexinfo ()
						ftn.name = substituteString texLineArray[2] "\"" ""
						local useLine = false
						if ft == "defaultflex" then (
							ftn.isDefault = true
							useLine = true
						) else if ft == "flex" OR ft == "flexpair" then (
							useLine = true
						)
						if useLine then (
							local findex = findItem texLineArray "frame"
							if findex != 0 then (
								local fvindex = findex + 1
								if texlinCount >= fvindex AND texLineArray[fvindex] != undefined then (
									ftn.frame = texLineArray[fvindex] as Integer

									lastFlexFile = thisModel.flexfile[thisModel.flexfile.count]
									append lastFlexFile.flexes ftn
								)

							)
						)

					)
				)
			)
		)
		MemStreamMgr.close texGstr
	)

)

function parseModelFileData &texGstr &qc &thisModel closeAtEnd:true = (
	if texGstr != undefined then (
		local splitStr
		local theFlagLine
		while texGstr.eos() == false AND texGstr.peekToken() != undefined do (
			--texGstr.skipSpace()
			local startPos = texGstr.pos()
			local texLine = texGstr.readLine()
			local endPos = texGstr.pos()
			texLine = trimRight(trimLeft (texLine))
			texLine = substituteString texLine "\t" " "
			texLine = substituteString texLine "  " " "
			texLineArray = filterString texLine " "
			local param = texLineArray[1]
			local val = undefined
			if texLineArray[2] != undefined then (
				val = substituteString texLineArray[2] "\"" ""
			)
			case of (
				(texLine == ""):(/*skip*/)
				(matchPattern texLine pattern:"*$include*"):(
					thisincludedqci = substituteString texLineArray[2] "\"" ""
					if doesFileExist thisincludedqci then (
						local theQCI = MemStreamMgr.openFile thisincludedqci
						parseFlexFileData &theQCI &qc &thisModel
					) else (
						local lookFor
						local hasFoundFile = false
						for pth in qc.paths while hasFoundFile == false do (
							lookfor = wallworm_backpathlookup pth thisincludedqci
							if doesFileExist (lookfor) then (
								local theQCI = MemStreamMgr.openFile lookfor
								parseFlexFileData &theQCI &qc &thisModel
								hasFoundFile = true
							)
						)
					)
				)
				((matchPattern param pattern:"*flexfile*") == true AND val != undefined) : (
					local fl = flexstruct()
					fl.flexfile = val
					append thisModel.flexfile fl
					if matchPattern texLine pattern:"*{*" then (
						texGstr.seek (startPos + (findString texLine "{") - 1) #seek_set
					)
					local str = texGstr.readBlock "{" "}"
					if str != undefined AND str != "" then (
						str = MemStreamMgr.openString str
						parseFlexFileData &str &qc &thisModel
					)
				)
				default:(
					local texlinCount = texLineArray.count
					if texlinCount >= 3 then (
						local ft = toLower (texLineArray[1])

						local ftn = flexinfo ()
						ftn.name = substituteString texLineArray[2] "\"" ""
						local useLine = false
						if ft == "defaultflex" then (
							ftn.isDefault = true
							useLine = true
						) else if ft == "flex" OR ft == "flexpair" then (
							useLine = true
						)
						if useLine then (
							local findex = findItem texLineArray "frame"
							if findex != 0 then (
								local fvindex = findex + 1
								if texlinCount >= fvindex AND texLineArray[fvindex] != undefined then (
									ftn.frame = texLineArray[fvindex] as Integer

									lastFlexFile = thisModel.flexfile[thisModel.flexfile.count]
									append lastFlexFile.flexes ftn
								)
							)
						)

					)
				)
			)
		)
		MemStreamMgr.close texGstr
	)
)

function wallworm_getSMDsFromPaths smdfile modelname qcfile type:"smd" extraPaths:undefined extraPath:undefined = (
	max create mode
	local out = undefined
	if smdfile != undefined then (
		/*
		This function returns a filename (with path) of a SMD represented by the modelname or undefined if not found.
		*/
		
		if getFileNamePath smdFile == "" then (
			smdFile = (getFileNamePath qcfile) + smdfile
		)
		
		
		if doesFileExist smdfile then (
			out = smdfile
		) else (
			patharray = #()

			if extraPaths != undefined then (
				if classOf extraPaths == Array then (
					join patharray extraPaths
				) else (
					append patharray (extraPaths)
				)
			)
			append patharray (::wwmt_gameInfoDir + "\\models\\")
			append patharray (::wwmt_export)
			if modelname != undefined then (
				append patharray (getFileNamePath modelname)
				append patharray (::wwmt_export + "\\" + getFileNamePath modelname)
			)
			append patharray (getFileNamePath smdfile)
			--append patharray (::wwmt_export+"\\"+ getFileNamePath smdfile)
			if qcfile != undefined AND qcfile != "" then (
				append patharray (getFileNamePath qcfile)
			)
			--append patharray (::wwmt_export+"\\"+ getFileNamePath qcfile)
			patharray = makeUniqueArray patharray
			local smdfname = getFileNameFile smdfile
			if getFileNameType smdfname != "" then (
				for p in patharray while out == undefined do (
					smd = wallworm_backpathlookup p smdfname
					if doesFileExist smd then (
						out = smd
					)
				)
			) else (
				local smdsmdname = (smdfname) + "." + type
				for p in patharray while out == undefined do (
					smd = wallworm_backpathlookup p smdsmdname
					if doesFileExist smd then (
						out = smd
					)
				)
				if out == undefined AND type != "vta" then (
					local smdsmdname = (smdfname) + ".dmx.smd"
					for p in patharray while out == undefined do (
						smd = wallworm_backpathlookup p smdsmdname
						if doesFileExist smd then (
							out = smd
						)
					)
				)
			)
		)
	)
	out
)

function createBonesFromDefineBones defineBonesList = (
	::t = defineBonesList
	for b in defineBonesList WHERE b.count >= 9 do (
		local bName = substituteString b[2] "\"" ""
		if bName != undefined AND bName != "" then (
			local bb = getNodeByName bName
			local bone_transform = Matrix3 1
			local xr, yr, zr
			xr = (b[7] as Float)
			if xr == undefined then (
				xr = 0
			)
			yr = (b[8] as Float)
			if yr == undefined then (
				yr = 0
			)
			zr = (b[9] as Float)
			if zr == undefined then (
				zr = 0
			)
			local rootRotationAngles = EulerAngles xr xr zr
			local x, y, z
			x = (b[4] as Float)
			if x == undefined then (
				x = 0
			)
			y = (b[5] as Float)
			if y == undefined then (
				y = 0
			)
			z = (b[6] as Float)
			if z == undefined then (
				z = 0
			)
			local bonePos = [x, y, z]
			if NOT isValidNode bb then (
				bb = (BoneSys.createBone [0, 0, 0] [1, 0, 0] [0, 0, 1])
				bb.showLinks = true
				bb.showLinksOnly = true
				bone_size = 0.1
				bb.width = bone_size
				bb.height = bone_size
				bb.boneEnable = true
				custAttributes.add bb ::wallworm_bone_CA
				bb.definebone = true
				bb.name = bName
			)
			local pName = substituteString b[3] "\"" ""
			local sys = Matrix3 1
			local pb
			if pName != "" then (
				pb = getNodeByName pName
				if isValidNode pb then (
					sys = pb
				)
			)
			in coordsys sys (
				bb.rotation = (eulerToQuat rootRotationAngles order:3)
				bb.pos = bonePos
			)
			bb.parent = pb
		)
	)
)

struct qclod (
	val = 1,
	replacemodels = #(),
	qciincludes = #(),
	replacematerials = #(),
	nofacial = false
)

struct qcbg (
	name,
	bgs = #()
)

struct hbset (
	name,
	hboxes = #()
)

struct weightlist (
	name,
	weights = #()
)

struct jigglecontainter (
	name,
	is_rigid = #(),
	is_flexible = #(),
	has_base_spring = #()
)
struct smdStorer (
	filename,
	data
)

struct wallworm_qc_struct (
	wwmt = undefined,
	body = undefined,
	models = #(),
	flexfile = #(),
	phys = undefined,
	staticprop = undefined,
	modelname = undefined,
	shortModelName = undefined,
	materialp = "",
	surfaceprop = undefined,
	concave = undefined,
	opaque = undefined,
	mostlyopaque = undefined,
	mass = undefined,
	inertia = undefined,
	damping = undefined,
	rotdamping = undefined,
	jointconstrain = false,
	shadowlod = false,
	texgroupname = "",
	texturegroup = #(),
	bodygroups = #(),
	sc = 1.0,
	lods = #(),
	lodvals = #(),
	seqvals = #(),
	sequences = #(),
	paths = #(),
	importedFiles = #(),
	includesToAdd = #(),
	unclassified = #(),
	upaxis = "z",
	collapsebones = undefined,
	qcfilepath = undefined,
	attachments = #(),
	hboxsets = #(),
	eyeballs = #(),
	eyepos = undefined,
	alwayscollapse = #(),
	weightlists = #(),
	definebones = #(),
	root = undefined,
	rootbone = undefined,
	jointconstraints = #(),
	jigglebones = #(),
	illumposition = undefined,
	masscenter = undefined,
	smdstore = #(),
	origin = undefined,
	offsets = undefined,
	nodes = #(),
	qcbones = #(),
	function getSMDFRomStore fname = (
		local store = undefined
		for s in smdstore while store == undefined do (
			if s.filename == fname then (
				store = s.data
			)
		)
		store
	)
)

function wallworm_update_qcobject &qc fsource skipLODS:false = (
	local out = undefined
	append qc.paths (getFileNamePath fsource)
	append qc.importedFiles (fileNameFromPath fsource)
	--local theQC = openFile fsource

	local lastHB
	local theQC = MemStreamMgr.openFile fsource

	if theQC != undefined then (
		if theQC.pos() != 0 then (
			theQC.seek 0 #seek_set
		)
		local theline
		while theQC.eos() == false AND theQC.peekToken() != undefined do (
			--theQC.skipSpace()
			local startPos = theQC.pos()
			theline = (theQC.readLine())
			endPos = theQC.pos()

			local val, param

			theLine = trimLeft theLine
			theLine = trimRight theLine
			--theLine = substituteString theLine "\tab" " "
			theLine = substituteString theLine "\t" " "
			theLine = substituteString theLine "  " " "

			--lines to ignore until support for these features are added (to speed gneeration up)		
			if (theLine == "" OR theLine == undefined OR ((substring theLine 1 2) == "//")) then (
				--skip
			) else (
				lineArray = filterString theLine " "

				if lineArray.count >= 1 then (
					param = lineArray[1]

				) else (
					param = theLine

				)

				if lineArray.count > 1 then (
					val = lineArray[2]

				) else (
					val = undefined

				)

				param = substituteString param "\"" ""

				if val != undefined then (
					val = substituteString val "\"" ""

				)

				--format "############\nParameter:\t%\nValue:\t%\n" param val

				case of (
					((matchPattern param pattern:"*$include*") == true AND val != undefined AND findItem qc.importedFiles (fileNameFromPath val) == 0) : (
						local hasFoundFile = false
						for pth in qc.paths while hasFoundFile == false do (
							local lookfor = wallworm_backpathlookup pth val
							if doesFileExist (lookfor) then (
								--print (lookfor + " found... parsing")
								wallworm_update_qcobject &qc lookfor
								hasFoundFile = true
							) else (
								--print (lookfor + " NOT found...")
							)
						)

						if hasFoundFile == false then (
							appendIfUnique qc.includesToAdd val

						) else (
							local ind = findItem qc.includesToAdd val
							if ind != 0 then (
								deleteItem qc.includesToAdd ind
							)
						)
					)

					((matchPattern param pattern:"*$modelname*") == true AND val != undefined) : (
						qc.shortModelName = getFileNameFile val
						qc.modelname = val
					)

					(matchPattern param pattern:"*$bodygroup*" == true) : (
						if val != undefined AND val != "" then (
							/*
							if qc.body == undefined then (
								qc.body = substituteString (lineArray[2]) "\"" ""
							) */

							bg = qcbg()
							bg.name = val

							if matchPattern param pattern:"*{*" then (
								theQC.seek (startPos + (findString theLine "{") - 1) #seek_set
							)

							local str = theQC.readBlock "{" "}"
							if str != undefined AND str != "" then (
								str = substituteString (substituteString (substituteString str "{" "") "}" "") "\"" ""
								local texGstr = MemStreamMgr.openString str
								local choicesarray = #()
								local splitStr
								local theFlagLine
								while texGstr.eos() == false AND texGstr.peekToken() != undefined do (
									texGstr.skipSpace()
									texLine = texGstr.readLine()

									texLine = trimRight(trimLeft (texLine))
									newbg = filterString texLine " "
									if newbg.count > 1 then (
										append bg.bgs newbg[2]
									)

								)

								MemStreamMgr.close texGstr

							)

							if bg.bgs.count > 0 then (
								append qc.bodygroups bg
							)

						)
					)

					(matchPattern param pattern:"*$jigglebone*" == true) : (
						if val != undefined AND val != "" then (
							--look for existing jigglebonerulle for bone

							local jigglebone = undefined
							for j in qc.jigglebones while jigglebone == undefined do (
								if j.name == val then (
									jigglebone = j
								)
							)
							if jigglebone == undefined then (
								jigglebone = jigglecontainter()
								jigglebone.name = val
								append qc.jigglebones jigglebone
							)
							if matchPattern theLine pattern:"*{*" then (
								theQC.seek (startPos + (findString theLine "{") - 1) #seek_set
							)

							local str = theQC.readBlock "{" "}"

							if str != undefined AND str != "" then (
								str = substituteString (substituteString (substituteString str "{" "") "}" "") "\"" ""
								local texGstr = MemStreamMgr.openString str
								local splitStr
								local theFlagLine
								local currentJiggleArray = undefined
								while texGstr.eos() == false AND texGstr.peekToken() != undefined do (
									texGstr.skipSpace()
									texLine = texGstr.readLine()
									texLine = trimRight(trimLeft (texLine))
									case of (
										(texLine == ""):(/*skip*/)
										(matchPattern texLine pattern:"*is_rigid*"):(
											currentJiggleArray = jigglebone.is_rigid
										)
										(matchPattern texLine pattern:"*is_flexible*"):(
											currentJiggleArray = jigglebone.is_flexible
										)
										(matchPattern texLine pattern:"*has_base_spring*"):(
											currentJiggleArray = jigglebone.has_base_spring
										)
										default:(
											if currentJiggleArray != undefined then (
												jigglevals = filterString texLine " "
												if jigglevals.count > 1 then (
													append currentJiggleArray jigglevals
												)
											)
										)
									)
								)
								MemStreamMgr.close texGstr
							)
						)
					)

					((matchPattern param pattern:"*$body*" == true) AND lineArray[3] != undefined) : (
						qc.body = substituteString (lineArray[3]) "\"" ""
					)

					((matchPattern param pattern:"*$model*" == true) AND lineArray[3] != undefined) : (
						--append qc.models (substituteString (lineArray[3]) "\"" "")
						local thisModel = (model filename:(substituteString (lineArray[3]) "\"" ""))

						if matchPattern theLine pattern:"*{*" then (
							theQC.seek (startPos + (findString theLine "{") - 1) #seek_set
						)

						local str = theQC.readBlock "{" "}"
						if str != undefined AND str != "" then (
							str = MemStreamMgr.openString str
							parseModelFileData &str &qc &thisModel
						)

						append qc.models thisModel
					)

					((matchPattern param pattern:"*$origin*" == true) AND lineArray[5] != undefined) : (
						qc.origin = lineArray
					)

					((matchPattern param pattern:"*$collisionjoints*" == true) AND val != undefined) : (
						--qc.jointconstrain = true
						qc.phys = substituteString (val) "\"" ""
						qc.concave = true
					)

					((matchPattern param pattern:"*$collisionmodel*" == true) AND val != undefined) : (
						qc.phys = substituteString (val) "\"" ""
					)

					(matchPattern param pattern:"*$sequence*" == true) : (
						append qc.seqvals lineArray
					)

					(matchPattern param pattern:"*$hboxset*" == true) : (
						if val == "" OR val == "default" then (
							if qc.hboxsets[1] != undefined then (
								lastHB = qc.hboxsets[1]
							) else (
								lastHB = hbset()
								lastHB.name = "default"
								append qc.hboxsets lastHB
							)
						) else (
							local hboxSetCount = qc.hboxsets.count
							local hb = undefined
							local hbindex = 1
							for hbindex = 1 to hboxSetCount while hb == undefined do (
								if qc.hboxsets[hbindex].name == val then (
									hb = qc.hboxsets[hbindex]
								)
							)
							if hb == undefined then (
								hb = hbset()
								hb.name = val
								append qc.hboxsets hb
							)
							lastHB = hb
						)
					)

					(matchPattern param pattern:"*$hbox*" == true) : (
						if lastHB == undefined then (
							if qc.hboxsets[1] != undefined then (
								lastHB = qc.hboxsets[1]
							) else (
								lastHB = hbset()
								lastHB.name = "default"
								append qc.hboxsets lastHB
							)
						)
						append lastHB.hboxes lineArray
					)

					(matchPattern param pattern:"*$attachment*" == true) : (
						append qc.attachments lineArray
					)

					(matchPattern param pattern:"*$staticprop*" == true) : (
						qc.staticprop = true
					)
					(matchPattern param pattern:"*$alwayscollapse*" == true AND val != undefined AND val != "") : (
						append qc.alwayscollapse val
					)

					(matchPattern param pattern:"*$definebone*" == true AND val != undefined AND val != "") : (
						append qc.definebones lineArray
					)

					(matchPattern param pattern:"*$rootbone*" == true AND val != undefined AND val != "") : (
						qc.rootbone = val
					)

					(matchPattern param pattern:"*$root*" == true AND val != undefined AND val != "") : (
						qc.root = val
					)

					(matchPattern param pattern:"*$upaxis*" == true AND val != undefined) : (
						qc.upaxis = toLower val
					)

					(matchPattern param pattern:"*$surfaceprop*" == true AND val != undefined) : (
						qc.surfaceprop = val
					)
					(matchPattern param pattern:"*$concave*" == true) : (
						qc.concave = true
					)

					(matchPattern param pattern:"*$mass*" == true AND val != undefined) : (
						qc.mass = val
					)

					(matchPattern param pattern:"*$illumposition*" == true AND val != undefined) : (
						qc.illumposition = lineArray
					)
					(matchPattern param pattern:"*$masscenter*" == true AND val != undefined) : (
						qc.masscenter = lineArray
					)
					(matchPattern param pattern:"*$scale*" == true AND val != undefined) : (
						qc.sc = val as Float
					)

					(matchPattern param pattern:"*$inertia*" == true AND val != undefined) : (
						qc.inertia = val
					)
					(matchPattern param pattern:"*$damping*" == true AND val != undefined) : (
						qc.damping = val
					)
					(matchPattern param pattern:"*$rotdamping*" == true AND val != undefined) : (
						qc.rotdamping = val
					)

					(matchPattern param pattern:"*$opaque*" == true) : (
						qc.opaque = true
					)
					(matchPattern param pattern:"*$mostlyopaque*" == true) : (
						qc.mostlyopaque = true
					)

					(matchPattern param pattern:"*$collapsebones*" == true) : (
						qc.collapsebones = true
					)

					(matchPattern param pattern:"*$pushd*" == true) : (
						--$pushd "../male_animations_sdk"
						appendIfUnique qc.paths (wallworm_backpathlookup2 (getFileNamePath fsource))

					)

					(matchPattern param pattern:"*$texturegroup*" == true AND val != undefined AND val != "") : (
						qc.texgroupname = val
						qc.texturegroup = #()
						if matchPattern param pattern:"*{*" then (
							theQC.seek startPos

						)

						local str = theQC.readBlock "{" "}"
						if str != undefined AND str != "" then (
							str = substituteString (substituteString (substituteString str "{" "") "}" "") "\"" ""

							local texGstr = MemStreamMgr.openString str
							local choicesarray = #()
							local splitStr
							local theFlagLine
							while texGstr.eos() == false AND texGstr.peekToken() != undefined do (
								texGstr.skipSpace()
								texLine = texGstr.readLine()

								texLine = trimRight(trimLeft (texLine))
								newTextures = filterString texLine " "
								if newTextures.count > 0 then (
									append qc.texturegroup newTextures
								)

							)

							MemStreamMgr.close texGstr

						)
					)

					(matchPattern param pattern:"*$weightlist*" == true AND val != undefined AND val != "") : (
						--See if there is a block
						local list = undefined
						for w in qc.weightlists while list == undefined do (
							if w.name == val then (
								list = w
							)
						)

						if list == undefined then (
							list = wwmt_weightlist()
							list.name = val
							append qc.weightlists list
						)

						if lineArray.count == 4 then (
							--single line
							local boneName = (substituteString lineArray[3] "\"" "")
							local wt = lineArray[4] as Float
							local ind = findItem list.bns boneName
							if ind == 0 then (
								--list.weights[ind] = wt
							) else (
								append list.bns boneName
								append list.weights wt
							)

						) else (
							if matchPattern param pattern:"*{*" then (
								theQC.seek startPos
							)
							local str = theQC.readBlock "{" "}"
							if str != undefined AND str != "" then (
								str = substituteString (substituteString (substituteString str "{" "") "}" "") "\"" ""
								local texGstr = MemStreamMgr.openString str
								local choicesarray = #()
								local splitStr
								local theFlagLine
								while texGstr.eos() == false AND texGstr.peekToken() != undefined do (
									texGstr.skipSpace()
									texLine = texGstr.readLine()
									texLine = trimRight(trimLeft (texLine))
									local wtline = filterString texLine " "
									if wtline.count > 1 then (
										append list.weights (#((substituteString lineArray[3] "\"" ""), (lineArray[4] as Float)))
										local boneName = (substituteString wtline[1] "\"" "")
										local wt = wtline[2] as Float
										local ind = findItem list.bns boneName
										if ind == 0 then (
											list.weights[ind] = wt
										) else (
											append list.bns boneName
											append list.weights wt
										)
									)
								)
								MemStreamMgr.close texGstr

							)
						)
					)

					(matchPattern param pattern:"*$lod*" == true AND val != undefined AND val != "") : (
						ld = qclod()
						ld.val = trimLeft(trimRight(substituteString (substituteString val "{" "") "\"" ""))

						if matchPattern param pattern:"*{*" then (
							theQC.seek startPos
						)

						local str = theQC.readBlock "{" "}"
						if str != undefined AND str != "" then (
							str = substituteString (substituteString (substituteString str "{" "") "}" "") "\"" ""
							local texGstr = MemStreamMgr.openString str
							local choicesarray = #()
							local splitStr
							local theFlagLine
							while texGstr.eos() == false AND texGstr.peekToken() != undefined do (
								texGstr.skipSpace()
								texLine = texGstr.readLine()

								texLine = trimRight(trimLeft (texLine))
								newld = filterString texLine " "

								case of (
									(matchPattern texLine pattern:"*replacemodel*" == true AND newld[3] != undefined) : (
										append ld.replacemodels (substituteString (newld[3]) "\"" "")
									)

									(matchPattern texLine pattern:"*replacematerial*" == true AND newld[3] != undefined) : (
										append ld.replacematerials (substituteString (newld[3]) "\"" "")
									)
									(texLine == "nofacial") :(
										ld.nofacial = true
									)

								)

							)

							MemStreamMgr.close texGstr

						)

						if ld.replacemodels.count > 0 then (
							append qc.lods ld
						)

					)

					(matchPattern param pattern:"*$cdmaterials*" == true AND val != undefined AND val != "") : (
						qc.materialp = val

					)

					(matchPattern param pattern:"*$jointconstrain*" == true AND val != undefined AND val != "") : (
						append qc.jointconstraints lineArray
					)

					(matchPattern param pattern:"*$eyeball*" == true AND val != undefined AND val != "") : (
						append qc.eyeballs = lineArray
						--eyeball (name) (bone name) (X) (Y) (Z) (material name) (diameter) (angle) (iris material) (pupil scale) 

					)
					(matchPattern param pattern:"*$eyeposition*" == true AND val != undefined AND val != "") : (
						qc.eyepos = lineArray
					)

					(matchPattern param pattern:"*$shadowlod*" == true) : (
						if NOT skipLODS then (
							qc.shadowlod = true
						)
					)

					default:(
						--"$jointmerge","$jointmassbias","$jointconstrain", bonemerge
						unclassed = #("$ikchain", "$poseparameter", "$bbox", "$proceduralbones")

						for u in unclassed do (
							if matchPattern param pattern:("*" + u + "*") == true AND val != undefined AND val != "" then (
								append qc.unclassified theLine

							)

						)

					)

				)

				/*
				if matchPattern param pattern:"*$lod*" == true AND val != undefined then (
					if NOT skipLODS then (
						append qc.lodvals val

					)
					continue
				) else (
					if matchPattern param pattern:"*$shadowlod*" == true  then (
						if NOT skipLODS then (
							qc.shadowlod = true
						)
						continue
					)

				)
				*/

			)

		)

		qc.paths = makeUniqueArray qc.paths
		qc.unclassified = makeUniqueArray qc.unclassified

		::gqc = qc

		memStreamMgr.close theQC

	)

)

function wallworm_make_wwmt_from_smd_in_qc qc smd rotateModel:false autoQuadrifyStaticprop:true condenseMesh:true rotationAmount:90 zeroRotations:false staticprop:false YUp:false xf:false uniqueNames:false collapseMeshes:false buildMesh:true scaleMesh:false extraSequences:undefined skipLODS:false deepSearchMaterials:false = (
	local wwmt

	if qc.staticprop == true then (
		rotateModel = true
		rotationAmount = 90
		zeroRotations = false
		xf = true
	) else (
		rotateModel = false
		rotationAmount = 0
		zeroRotations = false
		xf = false
		collapseMeshes = false
	)

	if qc.upaxis == "y" then (
		YUp = true
	)
	local qcbones = #()

	--local smd = wallworm_getSMDsFromPaths ffile flexfilename qc.qcfilepath type:"smd"

	local res = qc.getSMDFRomStore smd
	if res == undefined then (
		res = wallworm_import_smd smd materialp:qc.materialp staticprop:qc.staticprop condenseMesh:condenseMesh autoQuadrifyStaticprop:autoQuadrifyStaticprop offsets:qc.offsets YUp:YUp rotateModel:rotateModel rotationAmount:rotationAmount zeroRotations:zeroRotations xf:xf uniqueNames:uniqueNames collapseMeshes:collapseMeshes
		if res != undefined then (
			local s = smdStorer filename:smd
			s.data = deepcopy res
			append qc.smdstore s
		)
	)

	local meshes = res[1]
	if meshes.count > 0 AND isValidNode meshes[1] then (
		msh = meshes[1]
		qcbones = res[2]
		free res
		local wwmt = ww_LOD_wrapper()
		wwmt.setTargetModel msh wwmt

		wwmt.target.getWWMT()
		--Add to a named layer
		::wwmtImportsLayersWWMT = (ww_CreateLayer "Imported Models" forceFunc:true).addNode
		::wwmtImportsLayersWWMT wwmt.target
		for m in meshes do (
			::wwmtImportsLayersWWMT m
		)

		if newMultiMat != undefined then (
			wwmt.target.mat = newMultiMat
		)

		if qc.staticprop == true then (
			if rotateModel then (
				wwmt.target.rotateRefSystem = false
				wwmt.rotateRefSystem = false
			) else (
				wwmt.target.rotateRefSystem = true
				wwmt.rotateRefSystem = true
			)
		)

		if qc.models.count > 0 then (
			for mobject in qc.models do (
				local mfile = mobject.filename
				local mpart = getFileNameFile mfile
				local smda = wallworm_getSMDsFromPaths mfile mpart qc.qcfilepath type:"smd"

				local res = qc.getSMDFRomStore smda
				if res == undefined then (
					res = wallworm_import_smd smda vtanode:msh isSequence:false materialp:qc.materialp autoQuadrifyStaticprop:autoQuadrifyStaticprop condenseMesh:condenseMesh staticprop:qc.staticprop YUp:YUp offsets:qc.offsets rotateModel:rotateModel rotationAmount:rotationAmount zeroRotations:zeroRotations xf:xf uniqueNames:false collapseMeshes:false
					if res != undefined then (
						append qc.smdstore (smdStorer filename:smda data:(deepcopy res))
					)
				)

				local mmeshes = res[1]

				if res[2] != undefined then (
					join qcbones res[2]
				)
				if mmeshes != undefined then (
					for m in mmeshes do (
						append meshes m
						::wwmtImportsLayersWWMT m
					)
				)

				if mobject.flexfile.count > 0 then (
					for fdata in mobject.flexfile do (
						local finfo = fdata

						ffile = fdata.flexfile
						local flexfilename = getFileNameFile ffile
						local vta = wallworm_getSMDsFromPaths ffile flexfilename qc.qcfilepath type:"vta"

						local resV = qc.getSMDFRomStore vta
						if resV == undefined then (
							resV = wallworm_import_smd vta frameinfo:fdata vtanode:mmeshes[1] isSequence:false autoQuadrifyStaticprop:autoQuadrifyStaticprop materialp:qc.materialp condenseMesh:condenseMesh offsets:qc.offsets staticprop:qc.staticprop YUp:YUp rotateModel:rotateModel rotationAmount:rotationAmount zeroRotations:zeroRotations xf:xf uniqueNames:false collapseMeshes:false
							if resV != undefined then (
								append qc.smdstore (smdStorer filename:vta data:(deepcopy resV))
							)
						)

						local vatmeshes = resV[1]
						if resV[2] != undefined then (
							join qcbones resV[2]
						)
						for m in vatmeshes do (
							append meshes m
							::wwmtImportsLayersWWMT m
						)
						free resV
					)

				)

				free res
			)

		)
		/*
		if qc.flexfile.count > 0 then (
			for fdata in qc.flexfile do (
				ffile = fdata.flexfile
				local flexfilename = getFileNameFile ffile
				local vta = wallworm_getSMDsFromPaths ffile flexfilename qc.qcfilepath type:"vta"

				local res = qc.getSMDFRomStore vta
				if res == undefined then (
					res = wallworm_import_smd vta frameinfo:fdata vtanode:msh isSequence:false materialp:qc.materialp condenseMesh:condenseMesh offsets:qc.offsets staticprop:qc.staticprop YUp:YUp rotateModel:rotateModel rotationAmount:rotationAmount zeroRotations:zeroRotations xf:xf uniqueNames:false collapseMeshes:false
					if res != undefined then (
						append qc.smdstore (smdStorer filename:vta data:(deepcopy res))
					)
				)

				local vatmeshes = res[1]
				if res[2] != undefined then (
					join qcbones res[2]
				)
				for m in vatmeshes do (
					append meshes m
					::wwmtImportsLayersWWMT m
				)
				free res
			)

		)*/

		if wwmt.targets.count < 1 OR wwmt.targets[1] == undefined then (
		) else (
			if qc.staticprop == true then (
				if rotateModel then (
					wwmt.setRotateRefsystem true
				) else (
					wwmt.setRotateRefsystem false
				)
			) else (
				if rotateModel == true then (
					if rotationAmount != undefined then (
						setUserProp wwmt.target #imported_rotation_offset (rotationAmount as String)
					)

					wwmt.setRotateRefsystem false

				) else (
					wwmt.setRotateRefsystem false
				)

			)

			wwmt.setinternalOrigin true
			wwmt.setLocalOrigin true

			wwmt.setNormalMethod 2

			wwmt.setModelName(qc.shortModelName)
			wwmt.target.modelName = qc.shortModelName

			if qc.materialp != undefined AND qc.materialp != "" then (
				wwmt.setMaterialPath(qc.materialp)
			)

			wwmt.setModelPath(getFileNamePath qc.modelname)

			if qc.staticprop != undefined then (wwmt.setStaticprop(true)) else (
				wwmt.setStaticprop(false)
			)
			if qc.surfaceprop != undefined then (wwmt.setSurfaceProperty(qc.surfaceprop))
			if qc.concave != undefined then (wwmt.setConcave(true))
			if qc.opaque != undefined then (wwmt.setOpaque(true))
			if qc.mostlyopaque != undefined then (wwmt.setMostlyOpaque(true))

			if qc.mass != undefined then (wwmt.setMass(qc.mass))
			if qc.inertia != undefined then (wwmt.setInertia(qc.inertia))
			if qc.damping != undefined then (wwmt.setdamping(qc.damping))
			if qc.rotdamping != undefined then (wwmt.setRotDamping(qc.rotdamping))

			if qc.jointconstrain == true then (wwmt.setJointConstraints(true))
			if qc.shadowlod == true then (wwmt.setShadowlod(true))

			if qc.collapsebones == true then (wwmt.setCollapsebones(true))

			if meshes.count > 1 then (
				for n = 2 to meshes.count do (
					wwmt.addObjToObjects meshes[n]
				)
			)

			local scaleSMDs = false
			if qc.sc != undefined AND qc.sc != 0.0 AND qc.sc != 1.0 then (
				if scaleMesh == true then (
					scaleSMDs = true

				) else (
					wwmt.setScale(qc.sc)
				)

			)

			if scaleSMDs == true then (
				toScale = for obj in meshes WHERE obj.parent == undefined collect obj

				toScale.scale *= qc.sc
				if xf == true then (
					resetXForm toScale
					convertToPoly toScale

				)
			)
			qcbones = makeUniqueArray qcbones
			wwmt.target.bonelist = qcbones
		)
	)

	wwmt
)

function wallworm_parse_qc fsource removeUnweightedBonesFromSkin:false condenseMesh:true autoQuadrifyStaticprop:true rotateModel:false rotationAmount:90 YUp:false zeroRotations:false staticprop:false xf:false uniqueNames:false collapseMeshes:false buildMesh:true scaleMesh:false extraSequences:undefined skipLODS:false deepSearchMaterials:false = (
	max create mode
	local dfltInTangentType = #step, dfltOutTangentType = #step, OLDdfltInTangentType, OLDdfltOutTangentType

	maxOps.getDefaultTangentType OLDdfltInTangentType OLDdfltOutTangentType
	maxOps.setDefaultTangentType dfltInTangentType dfltOutTangentType writeInCfgFile:false

	undo off (
		global wallworm_smd_import_time = sliderTime

		global qc = wallworm_qc_struct()
		qc.qcfilepath = fsource

		wallworm_update_qcobject &qc fsource skipLODS:skipLODS

		if buildMesh == true then (
			local extraRootPaths = #(qc.materialp)
			local fsourcepath = getFileNamePath fsource
			local newMultiMat
			if qc.texturegroup.count > 0 then (
				newMultiMat = MultiMaterial name:(qc.texgroupname) numsubs:qc.texturegroup.count

				skincount = 1
				for sk in qc.texturegroup WHERE sk.count > 0 do (
					if sk.count == 1 then (
						local vmt = (wallworm_VMFIMPORT_getMaterial (sk[1]) Color:undefined openLib:false matType:"model" extraPath:fsourcepath extraRootPaths:extraRootPaths)

						if vmt == undefined then (
							vmt = Standard name:(sk[1])
						)

						newMultiMat.materialList[skincount] = vmt
					) else (
						local subskinMulti = MultiMaterial name:(("Skin" + skincount as String)) numsubs:sk.count
						skCount = 1
						for multsk in sk do (
							local vmt = (wallworm_VMFIMPORT_getMaterial (multsk) Color:undefined openLib:false matType:"model" extraPath:fsourcepath extraRootPaths:extraRootPaths)
							if vmt == undefined then (
								vmt = Standard name:(multsk)
							)
							subskinMulti.materialList[skCount] = vmt
							skCount += 1
						)
						newMultiMat.materialList[skincount] = subskinMulti

					)
					newMultiMat.names[skincount] = ("Skin" + skincount as String)
					skincount += 1
				)

			)

			if qc.definebones.count > 0 then (
				--createBonesFromDefineBones qc.definebones
			)

			if qc.modelname != undefined AND (qc.body != undefined OR qc.models.count > 0 OR qc.flexfile.count > 0 OR qc.bodygroups.count > 0) then (
				if qc.staticprop != undefined AND NOT qc.staticprop then (
					rotateModel = false
					rotationAmount = 0
					zeroRotations = false
					xf = false
					collapseMeshes = false
				) else (
					if qc.staticprop == true then (
						rotateModel = true
						--rotationAmount = 90
						zeroRotations = false
						xf = true
						--xf = true  
						collapseMeshes = true
						uniqueNames = true

					)

				)

				if qc.origin != undefined then (
					--originMatrix = matrix3 [1,0,0] [0,1,0] [0,0,1] [(qc.origin[2] as float), (qc.origin[3] as float),(qc.origin[4] as float)]
					--originMatrix = originMatrix * (rotateZMatrix rotationAmount) 
					qc.offsets = [((qc.origin[2] as Float)), ((qc.origin[3] as Float)), (qc.origin[4] as Float)]
					--rotationAmount = (qc.origin[5] as float) * -1
				)

				local smd
				local skipModel1 = false
				local skipBG1 = false
				local skipVTA1 = false

				if qc.body != undefined then (
					smd = wallworm_getSMDsFromPaths qc.body qc.modelname fsource
				)
				--print smd

				if smd == undefined AND qc.models.count > 0 then (
					smd = wallworm_getSMDsFromPaths qc.models[1].filename qc.modelname fsource
					skipModel1 = true
				)
				/*
				if smd == undefined AND qc.flexfile.count > 0 then (
					smd = wallworm_getSMDsFromPaths qc.flexfile[1] qc.modelname fsource
					skipVTA1 = true
				)*/

				if smd == undefined AND qc.bodygroups.count > 0 then (
					smd = wallworm_getSMDsFromPaths qc.bodygroups[1].bgs[1] qc.modelname fsource
					if qc.bodygroups.count == 1 AND qc.bodygroups[1].bgs.count == 1 then (
						qc.bodygroups = #() --this means there model found the Bodygroup command but no Body, probably decompiled with Crowbar
					)
					skipBG1 = true
				)

				if smd != undefined AND smd != "" then (
					wwmt = wallworm_make_wwmt_from_smd_in_qc qc smd rotateModel:rotateModel condenseMesh:condenseMesh autoQuadrifyStaticprop:autoQuadrifyStaticprop offsets:qc.offsets rotationAmount:rotationAmount YUp:YUp zeroRotations:zeroRotations staticprop:qc.staticprop xf:xf uniqueNames:uniqueNames collapseMeshes:collapseMeshes

					if wwmt != undefined then (
						wwmt.target.mat = newMultiMat
						local qcistr = wwmt.createCustomQCI()

						if doesFileExist qcistr then (
							if qc.includesToAdd.count > 0 OR qc.unclassified.count > 0 then (
								local CustomQCFile = openFile(qcistr) mode:"a"

								for inc in qc.includesToAdd do (
									str = "$include \"" + inc + "\"\n"
									format str to:CustomQCFile
								)

								for inc in qc.unclassified do (
									str = inc + "\n"
									format str to:CustomQCFile
								)

								try (
									close CustomQCFile
									free CustomQCFile
									flush CustomQCFile
								) catch ()

							)

						)

						/*
						tempWWMT.setBase(base)

						tempWWMT.setDmg_bullets(dmg_bullets)
						tempWWMT.setDmg_club(dmg_club)
						tempWWMT.setDmg_explosive(dmg_explosive)
						tempWWMT.setFadetime(fadetime)
						*/

						if qc.phys != undefined then (
							if qc.body != undefined AND toLower (qc.body) == toLower (qc.phys) then (
								wwmt.setAutoHull(true)

							) else (
								physsmd = wallworm_getSMDsFromPaths qc.phys qc.modelname fsource

								if physsmd != undefined then (
									local res = wallworm_import_smd physsmd materialp:qc.materialp condenseMesh:condenseMesh autoQuadrifyStaticprop:autoQuadrifyStaticprop YUp:YUp deepSearchMaterials:deepSearchMaterials offsets:qc.offsets removeUnweightedBonesFromSkin:removeUnweightedBonesFromSkin rotateModel:rotateModel rotationAmount:rotationAmount zeroRotations:zeroRotations xf:xf uniqueNames:uniqueNames collapseMeshes:collapseMeshes staticprop:qc.staticprop skipAnimation:true staticprop:qc.staticprop addToTimeline:false isSequence:false
									mshphy = res[1]
									if mshphy != undefined AND mshphy.count > 0 then (
										::wwmtImportsLayersCollision = (ww_CreateLayer "Imported Collision Hulls" forceFunc:true).addNode

										for h in mshphy WHERE isValidNode h do (
											::wwmtImportsLayersCollision h
											wwmt.appendHull h
										)

										wwmt.processPhys()
										hide wwmt.hulls

									)
									free res
									if scaleSMDs == true then (
										toScale = for obj in mshphy WHERE obj.parent == undefined collect obj

										toScale.scale *= qc.sc
										if xf == true then (
											resetXForm toScale
											convertToPoly toScale

										)
									)

								)
							)

						)

						if NOT skipLODS then (
							/*
							if qc.shadowlod == true AND qc.lods.count > 0 then (
								deleteItem qc.lods qc.lods.count
							)
							*/

							if qc.lods.count > 0 then (
								::wwmtImportsLayersLODS = (ww_CreateLayer "Imported LODs" forceFunc:true).addNode
								for i = 1 to qc.lods.count do (
									ld = qc.lods[i]

									newLod = ww_lod()

									newLod.wrapper = wwmt
									newLod.level = i
									newLod.metric = ld.val as Float
									newLod.newMR()
									newLod.setGizmo (64 * i)
									newLod.nofacial = ld.nofacial

									for m in ld.replacemodels do (
										smd = wallworm_getSMDsFromPaths (getFileNameFile m) qc.modelname fsource

										if smd != undefined AND smd != "" then (
											local res = qc.getSMDFRomStore smd
											if res == undefined then (
												res = wallworm_import_smd smd materialp:qc.materialp condenseMesh:condenseMesh YUp:YUp autoQuadrifyStaticprop:autoQuadrifyStaticprop deepSearchMaterials:deepSearchMaterials offsets:qc.offsets removeUnweightedBonesFromSkin:removeUnweightedBonesFromSkin rotateModel:rotateModel rotationAmount:rotationAmount zeroRotations:zeroRotations xf:xf uniqueNames:uniqueNames collapseMeshes:collapseMeshes staticprop:qc.staticprop addToTimeline:false isSequence:false
												if res != undefined then (
													local s = smdStorer filename:smd
													s.data = deepcopy res
													append qc.smdstore s
												)
											)

											l = res[1]
											if l != undefined AND l.count > 0 then (
												if l.count > 0 then (
													for lodin = 1 to l.count do (
														append newLod.items l[lodin]
														hide l[lodin]
														::wwmtImportsLayersLODS l[lodin]
													)
												)
												hide l
												if scaleSMDs == true then (
													toScale = for obj in l WHERE obj.parent == undefined collect obj

													toScale.scale *= qc.sc
													if xf == true then (
														resetXForm toScale
														convertToPoly toScale

													)
												)
											)
											free res
										)
									)
									newLod.setCustomAttributes()
									newLod.helperTape.setRadiusFromMetric (ld.val as Float)
									newLod.helperTape.nofacial = ld.nofacial
									::wwmtImportsLayersLODS newLod.helperTape
									::wwmtImportsLayersLODS newLod.helperGizmo
									append wwmt.lods newLod

									newMats = #()
									for m in ld.replacematerials do (
										local theVMT = wallworm_VMFIMPORT_getMaterial (m) Color:undefined openLib:false matType:"model" extraPath:fsourcepath extraRootPaths:extraRootPaths

										if theVMT != undefined then (
											append newMats theVMT
											--mat.materialList[i] = wallworm_generateMaterialFromVMT theVMT matType:"model" extraPath:materialp 

										)

									)

									if newMats.count > 0 then (
										lodmat = MultiMaterial numsubs:newMats.count name:(wwmt.modelname + " LOD " + newLod.level as String + " Material")
										for mi = 1 to newMats.count do (
											lodmat.materialList[mi] = newMats[mi]
										)
										newLod.helperTape.setLODMaterial lodmat

									)

								)

							)

						)
						usedSequenceNames = #()
						if qc.seqvals.count > 0 AND qc.staticprop != true then (
							global wwmt_sequence

							local bonelist = wwmt.target.bonelist

							--AnimLayerManager.enableLayers bonelist pos:true rot:true scale:false ik:true object:false -- customAtt:<boolean> mod:<boolean> mat:<boolean> other:<boolean>

							for seq in qc.seqvals WHERE seq.count >= 3 AND seq[2] != "idle" do (
								local seqnam = substituteString seq[3] "\"" ""
								--AnimLayerManager.addLayer seqnam bonelist false
								--local currentLayer = AnimLayerManager.getLayerCount()
								--AnimLayerManager.setLayerActive currentLayer
								smd = wallworm_getSMDsFromPaths (seqnam + ".smd") seqnam fsource extrapaths:qc.paths
								--AnimLayerManager.setLayerLocked currentLayer true

								if smd != undefined AND smd != "" then (
									append usedSequenceNames (seqnam + ".smd")
									wwseq = wwmt_sequence()
									wwseq.type = "Sequence"
									wwseq.sequence = substituteString seq[2] "\"" ""

									if wwseq.sequence == "idle" then (
										--the qc defined a custom idle sequence... so use that one
										wwmt.setIdleSequence false
									)

									local ct = seq.count

									local actPlace = findItem seq "activity"
									actVal = actPlace + 1
									if actPlace != 0 AND actVal <= ct AND seq[actVal] != undefined then (
										wwseq.activity = seq[actVal]
									)

									activityWeightPlace = actVal + 1
									if activityWeightPlace <= ct AND seq[activityWeightPlace] != undefined AND seq[activityWeightPlace] as Float != undefined then (
										wwseq.activityWeight = seq[activityWeightPlace] as Float
									)

									local actPlace = findItem seq "node"
									actVal = actPlace + 1
									if actPlace != 0 AND actVal <= ct AND seq[actVal] != undefined then (
										wwseq.nd = seq[actVal] as String
									)

									local fpsPlace = findItem seq "fps"
									actVal = fpsPlace + 1
									if fpsPlace != 0 AND actVal <= ct AND seq[actVal] != undefined then (
										wwseq.fps = seq[actVal] as Float
									)

									lookforsimple = #("autoplay", "snap", "realtime", "hidden")
									for prop in lookforsimple do (
										if findItem seq prop == 0 then (
											setProperty wwseq prop false
										) else (
											setProperty wwseq prop true
										)
									)

									if findItem seq "loop" == 0 then (
										wwseq.loop = 0
									) else (
										wwseq.loop = 1
									)

									local fadeInPlace = findItem seq "fadein"
									if fadeInPlace == 0 then (
										fadeInPlace = findItem seq "fadeIn"
									)
									actVal = fadeInPlace + 1
									if fadeInPlace != 0 AND actVal <= ct AND seq[actVal] != undefined then (
										wwseq.fadeIn = seq[actVal]
									)

									local fadeOutPlace = findItem seq "fadeout"
									if fadeOutPlace == 0 then (
										fadeOutPlace = findItem seq "fadeOut"
									)
									actVal = fadeOutPlace + 1
									if fadeOutPlace != 0 AND actVal <= ct AND seq[actVal] != undefined then (
										wwseq.fadeOut = seq[actVal]
									)

									wwseq.start = ::wallworm_smd_import_time + 1

									FrameTagManager.CreateNewTag wwseq.sequence wwseq.start

									--AnimLayerManager.enableLayers nodes pos:true rot:true scale:false ik:true object:false customAtt:false mod:false mat:false other:false

									s = wallworm_import_smd smd materialp:qc.materialp condenseMesh:condenseMesh autoQuadrifyStaticprop:autoQuadrifyStaticprop deepSearchMaterials:deepSearchMaterials offsets:qc.offsets YUp:YUp removeUnweightedBonesFromSkin:removeUnweightedBonesFromSkin rotateModel:rotateModel rotationAmount:rotationAmount zeroRotations:zeroRotations xf:xf uniqueNames:false collapseMeshes:false staticprop:false isSequence:true timeOffset:::wallworm_smd_import_time seqName:"seq"
									wwseq.end = ::wallworm_smd_import_time
									wwseq.setSequence wwmt.target
									append wwmt.sequences wwseq
								)
							)
						)

						/*Now add sequences from those derived from a folder.*/
						if qc.staticprop != true AND extraSequences != undefined AND doesFileExist extraSequences then (
							global wwmt_sequence
							local autoimportseqs = getFiles (extraSequences + "\\*.smd")
							if autoimportseqs != undefined AND autoimportseqs.count > 0 then (
								for autoseq in autoimportseqs do (
									seqnam = getFilenameFile autoseq

									if findItem usedSequenceNames seqnam == 0 then (
										smd = wallworm_getSMDsFromPaths (autoseq) seqnam fsource
										if smd != undefined AND smd != "" then (
											wwseq = wwmt_sequence()
											wwseq.type = "Sequence"
											wwseq.sequence = seqnam

											wwseq.start = ::wallworm_smd_import_time + 1
											FrameTagManager.CreateNewTag wwseq.sequence wwseq.start
											s = wallworm_import_smd smd materialp:qc.materialp condenseMesh:condenseMesh deepSearchMaterials:deepSearchMaterials offsets:qc.offsets YUp:YUp removeUnweightedBonesFromSkin:removeUnweightedBonesFromSkin rotateModel:rotateModel rotationAmount:rotationAmount zeroRotations:zeroRotations xf:xf uniqueNames:false collapseMeshes:false staticprop:false isSequence:true timeOffset:::wallworm_smd_import_time seqName:"seq"
											wwseq.end = ::wallworm_smd_import_time
											wwseq.setSequence wwmt.target
											append wwmt.sequences wwseq
										)

									)

								)
							)
						)
						if wwmt.sequences.count > 0 then (
							wwmt.setSeqListCust()
						)

						local bgMapNames = #(qc.body)
						if qc.bodygroups.count > 0 then (
							::wwmtImportsLayersBodygroups = (ww_CreateLayer "Imported Bodygroups" forceFunc:true).addNode
							local startPos = wwmt.target.pos + [0, 64, 0]
							for bg in qc.bodygroups do (
								local bgDummy = Dummy pos:startPos name:bg.name
								custAttributes.add bgDummy wallworm_bodygroup_CA
								for bodyline in bg.bgs do (
									if findItem bgMapNames bodyline == 0 then (
										smd = wallworm_getSMDsFromPaths bodyline qc.modelname fsource
										if smd != undefined then (
											bgwwmt = wallworm_make_wwmt_from_smd_in_qc qc smd YUp:YUp
											bgwwmt.setModelName (getFileNameFile smd)

											append bgDummy.wwmts bgwwmt.target

											startPos += [0, 64, 0]
											bgwwmt.target.pos = startPos
										)
									)
								)
								::wwmtImportsLayersBodygroups bgDummy
								bgDummy.parent = wwmt.target

								startPos += [0, 64, 0]
							)
						)
						setUserProp wwmt.target #WW_SMDImported "true"
						select (wwmt.target)
					)

					if qc.hboxsets.count > 0 then (
						::wwmtImportsLayersHitboxes = (ww_CreateLayer "Imported Hitboxes" forceFunc:true).addNode
						for hbset in qc.hboxsets do (
							local hbname = hbset.name
							for vals in hbset.hboxes do (
								--create the hbox
								if vals.count >= 9 then (
									local pb = getNodeByName (substituteString vals[3] "\"" "") --parent bone

									if isValidNode pb then (
										local hb = wwmt_createBoneHitbox pb hbset:hbname grp:(vals[2] as Integer)
										if isValidNode hb then (
											hb.parent = undefined
											local min = [(vals[4] as Float), (vals[5] as Float), (vals[6] as Float)]
											local maxB = [(vals[7] as Float), (vals[8] as Float), (vals[9] as Float)]

											hb.height = maxB.z - min.z
											hb.width = maxB.x - min.x
											hb.length = maxB.y - min.y

											/*
											len  = x
											ht = y
											width = z*/

											local cent = (min + maxB) / 2

											local offset = [cent.x, cent.y, min.z]

											in coordsys pb (
												hb.pos += offset

											)

											if vals.count >= 12 then (
												local rot = EulerAngles (vals[10] as Float) (vals[11] as Float) (vals[12] as Float)
												--local rot = eulerAngles  (vals[11] as float) (vals[12] as float) (vals[10] as float)
												in coordsys pb hb.rotation = inverse (eulerToQuat rot order:3)

											)

											hb.parent = pb

											wwmtImportsLayersHitboxes hb

										)

									)
								)
							)

						)

					)

					if qc.attachments.count > 0 then (
						::wwmtImportsLayersAttachments = (ww_CreateLayer "Imported Attachments" forceFunc:true).addNode
						for vals in qc.attachments do (
							--$attachment "forward" "ValveBiped.forward" 0 0 0 rigid absolute rotate 0 0 0

							local lbl = vals[2]
							lbl = substituteString lbl "\"" ""

							local pb = undefined
							local par = vals[3]

							par = substituteString par "\"" ""
							if par != "" then (
								pb = getNodeByName par
							)

							local rigid = false
							if findItem vals "rigid" > 6 then (
								rigid = true
							)

							local absolute = false
							if findItem vals "absolute" > 6 then (
								absolute = true
							)

							if NOT absolute AND isValidNode pb then (
								coordsy = pb
							) else (
								coordsy = Matrix3 1
							)

							local atmt = wwmt.createNewAttachment absolute:absolute rigid:rigid label:lbl asBone:false

							local posIndex = 4
							local posIndex1 = undefined
							for posIndex = 4 to vals.count while posIndex1 == undefined do (
								if vals[posIndex] != undefined AND vals[posIndex] != "" AND vals[posIndex] as Float != undefined then (
									posIndex1 = posIndex
								)
							)

							if (vals.count >= (posIndex + 2)) AND (vals[posIndex] != undefined AND vals[posIndex + 1] != undefined AND vals[posIndex + 2] != undefined) then (
								local x, y, z
								x = vals[posIndex] as Float
								y = vals[posIndex + 1] as Float
								z = vals[posIndex + 2] as Float
								if x != undefined AND y != undefined AND z != undefined then (
									local pos = [x, y, z]
									in coordsys coordsy atmt.atPoint.position = pos
								)

							)
							local rot = false
							local rotIndex = findItem vals "rotate"
							if rotIndex > 6 AND ((rotIndex + 3) <= vals.count) then (
								local rot = EulerAngles (vals[rotIndex + 1] as Float) (vals[rotIndex + 2] as Float) (vals[rotIndex + 3] as Float)

								in coordsys coordsy atmt.atPoint.rotation = eulerToQuat rot order:3

								/*
								1 - XYZ
								2 - XZY
								3 - YZX
								*/

							)

							if isValidNode pb then (
								atmt.atPoint.parent = pb
							)
							::wwmtImportsLayersAttachments atmt.atPoint

						)

					)

				)

			)
			if qc.weightlists.count > 0 then (
				for wt in qc.weightlists do (
					wt.writeWeightListToObject wwmt.target
				)
			)

			if qc.jigglebones.count > 0 then (
				for j in qc.jigglebones do (
					local bn = getNodeByName j.name
					if isValidNode bn then (
						if NOT isProperty bn #wallworm_bone_CA then (
							custAttributes.add bn ::wallworm_bone_CA
						)

						bn.useJiggleProps = true
						bn.jigglebone = true

						if j.is_flexible.count > 0 then (
							bn.jigglebone_is_flexible = true

							for v in j.is_flexible do (
								param = substituteString v[1] "\"" ""
								if param == "allow_length_flex" then (
									bn.jigglebone_allow_length_flex = true
								) else (
									val = v[2]
									if val != undefined then (
										paramNameUse = ("use_jigglebone_" + param)
										if isProperty bn paramNameUse then (
											setProperty bn paramNameUse true
											paramNames = #(("jigglebone_" + param), ("jigglebone_" + param + "_min"))
											if isProperty bn (paramNames[1]) then (
												setProperty bn (paramNames[1]) (val as Float)
											) else if isProperty bn (paramNames[2]) then (
												setProperty bn (paramNames[2]) (val as Float)
											)
											val2 = v[3]
											if val2 != undefined then (
												local p2 = "jigglebone_" + param + "_max"
												if isProperty bn (p2) then (
													setProperty bn (p2) (val as Float)
												)
											)
										)
									)
								)
							)
						)

						if j.is_rigid.count > 0 then (
							bn.jigglebone_is_rigid = true
							for v in j.is_rigid do (
								param = substituteString v[1] "\"" ""
								val = v[2]
								if val != undefined then (
									paramNameUse = ("use_jigglebone_" + param)
									if isProperty bn paramNameUse then (
										setProperty bn paramNameUse true
										paramNames = #(("jigglebone_" + param), ("jigglebone_" + param + "_min"))
										if isProperty bn (paramNames[1]) then (
											setProperty bn (paramNames[1]) (val as Float)
										) else if isProperty bn (paramNames[2]) then (
											setProperty bn (paramNames[2]) (val as Float)
										)
										val2 = v[3]
										if val2 != undefined then (
											local p2 = "jigglebone_" + param + "_max"
											if isProperty bn (p2) then (
												setProperty bn (p2) (val as Float)
											)
										)
									)
								)
							)
						)

						if j.has_base_spring.count > 0 then (
							bn.jigglebone_has_base_spring = true
							for v in j.has_base_spring do (
								param = substituteString v[1] "\"" ""
								val = v[2]
								if val != undefined then (
									paramNameUse = ("use_jigglebone_" + param)
									if isProperty bn paramNameUse then (
										setProperty bn paramNameUse true
										paramNames = #(("jigglebone_" + param), ("jigglebone_" + param + "_min"))
										if isProperty bn (paramNames[1]) then (
											setProperty bn (paramNames[1]) (val as Float)
										) else if isProperty bn (paramNames[2]) then (
											setProperty bn (paramNames[2]) (val as Float)
										)
										val2 = v[3]
										if val2 != undefined then (
											local p2 = "jigglebone_" + param + "_max"
											if isProperty bn (p2) then (
												setProperty bn (p2) (val as Float)
											)
										)
									)
								)
							)
						)
					)

				)

			)

			struct iktemp (
				bn,
				xType = "free",
				xRange = [0, 0],
				xFriction = 0.0,
				yType = "free",
				yRange = [0, 0],
				yFriction = 0.0,
				zType = "free",
				zRange = [0, 0],
				zFriction = 0.0
			)

			if qc.jointconstraints.count > 0 then (
				qc.jointconstrain = true

				local storage = #()

				for jc in qc.jointconstraints do (
					--first build up all the constraints
					local bn = getNodeByName (substituteString jc[2] "\"" "")
					if isValidNode bn then (
						local ikstore = undefined
						for ikval in storage while ikstore == undefined do (
							if ikval.bn == bn then (
								ikstore = ikval
							)
						)
						if ikstore == undefined then (
							ikstore = iktemp()
							ikstore.bn = bn
							append storage ikstore
						)
						case (toLower (substituteString jc[3] "\"" "")) of (
							"x":(
								ikstore.xType = (substituteString jc[4] "\"" "")
								ikstore.xRange = [(jc[5] as Float), (jc[6] as Float)]
								ikstore.xFriction = jc[7] as Float
							)
							"y":(
								ikstore.yType = (substituteString jc[4] "\"" "")
								ikstore.yRange = [(jc[5] as Float), (jc[6] as Float)]
								ikstore.yFriction = jc[7] as Float
							)
							"z":(
								ikstore.zType = (substituteString jc[4] "\"" "")
								ikstore.zRange = [(jc[5] as Float), (jc[6] as Float)]
								ikstore.zFriction = jc[7] as Float
							)
						)

					)
				)

				local iksetAxisLimit = ik.setAxisLimit
				local iksetAxisActive = ik.setAxisActive
				local iksetAxisDamping = ik.setAxisDamping

				local iksetAxisMin = ik.setAxisMin
				local iksetAxisMax = ik.setAxisMax

				for j in storage do (
					bn = j.bn
					x = j.xRange
					y = j.yRange
					z = j.zRange

					local axisActive = #{}
					local axisLimit = #{}

					if j.xType == "fixed" then (
						x = [0, 0]
						axisActive[1] = false
						axisLimit[1] = true
					) else (
						x = j.xRange
						axisActive[1] = true

						if j.xType == "limit" then (
							axisLimit[1] = true
						) else (
							axisLimit[1] = false
						)

					)

					if j.yType == "fixed" then (
						x = [0, 0]
						axisActive[2] = false
						axisLimit[2] = true
					) else (
						x = j.yRange
						axisActive[2] = true

						if j.yType == "limit" then (
							axisLimit[2] = true
						) else (
							axisLimit[2] = false
						)

					)

					if j.zType == "fixed" then (
						x = [0, 0]
						axisActive[3] = false
						axisLimit[3] = true
					) else (
						x = j.zRange
						axisActive[3] = true

						if j.zType == "limit" then (
							axisLimit[3] = true
						) else (
							axisLimit[3] = false
						)

					)

					iksetAxisLimit bn #rotational axisLimit
					iksetAxisActive bn #rotational axisActive
					iksetAxisDamping bn #rotational [j.xFriction, j.yFriction, j.zFriction]
					iksetAxisMin bn #rotational [x.x, y.x, z.x]
					iksetAxisMax bn #rotational [x.y, y.y, z.y]

				)
				free storage

			)

			if qc.illumposition != undefined then (
				local pt = wwmt.createIlluminationHelper()
				local sys = Matrix3 1
				if qc.illumposition[5] != undefined then (
					local pb = getNodeByName qc.illumposition[5]
					if isValidNode pb then (
						sys = pb
					)
				)
				in coordsys sys pt.position = [(qc.illumposition[2] as Float), (qc.illumposition[3] as Float), (qc.illumposition[4] as Float)]
				::wwmtImportsLayersWWMT pt
			)
			if qc.masscenter != undefined then (
				local pt = wwmt.createMassHelper()
				pt.position = [(qc.masscenter[2] as Float), (qc.masscenter[3] as Float), (qc.masscenter[4] as Float)]
				::wwmtImportsLayersWWMT pt
			)

			if qc.eyepos != undefined then (
				local eyeball = wwmt.target.getEyePosition()
				eyeball.position = [(qc.eyepos[2] as Float), (qc.eyepos[3] as Float), (qc.eyepos[4] as Float)]
				::wwmtImportsLayersWWMT eyeball
			)

			if qc.eyeballs.count > 0 then (
				for eyedata in qc.eyeballs do (
					--eyeball (name) (bone name) (X) (Y) (Z) (material name) (diameter) (angle) (iris material) (pupil scale) 
					local eye = wwmt.target.createEyeball()
					eye.name = substituteString (eyedata[2]) "\"" ""
					local pname = substituteString (eyedata[3]) "\"" ""
					local pos = [eyedata[4] as Float, eyedata[5] as Float, eyedata[6] as Float]
					local matname = substituteString (eyedata[7]) "\"" ""
					local dia = eyedata[8] as Float
					local ang = eyedata[9] as Float
					local irismatname = substituteString (eyedata[10]) "\"" ""
					local pupScale = eyedata[11] as Float
					eye.pos = pos
					eye.radius = dia / 2

					local theVMT = wallworm_VMFIMPORT_getMaterial (matname) Color:white openLib:false matType:"model" extraPath:qc.materialp extraRootPaths:fsourcepath

					if theVMT != undefined then (
						eye.mat = theVMT
					)

					local par = getNodeByName pname
					if isValidNode par then (
						eye.parent = par
					)
					::wwmtImportsLayersWWMT eye
				)

			)

			sliderTime = ::wallworm_smd_import_time

		) else (
			/*all we want is the modelname*/
			wwmt = qc.modelname
		)

	)

	if ::wallworm_debug == true then (
		if ::ww_qcarray == undefined then (
			::ww_qcarray = #()
		)
		append ::ww_qcarray (#(qc, wwmt))
		--format "\n########\nMesh Count: %\nMeshes: %\nCollapse?: %\n" meshes.count meshes collapseMeshes		
	)

	::wallworm_smd_import_time = 0
	sliderTime = 0

	if OLDdfltInTangentType != undefined AND OLDdfltOutTangentType != undefined then (
		maxOps.setDefaultTangentType OLDdfltInTangentType OLDdfltOutTangentType writeInCfgFile:false
	)

	wwmt
)

function wallworm_import_qc_from_filename fsource saveToLib:true noVMF:true condenseMesh:true removeUnweightedBonesFromSkin:false skipLODS:false YUp:false deepSearchMaterials:true staticprop:false rotateModel:false zeroRotations:false xf:false uniqueNames:false collapseMeshes:false scaleMesh:false extraSequences:"" = (
	local wwmt = wallworm_parse_qc fsource removeUnweightedBonesFromSkin:removeUnweightedBonesFromSkin condenseMesh:condenseMesh skipLODS:skipLODS deepSearchMaterials:deepSearchMaterials YUp:YUp staticprop:staticprop rotateModel:rotateModel zeroRotations:zeroRotations xf:xf uniqueNames:uniqueNames collapseMeshes:collapseMeshes scaleMesh:scaleMesh extraSequences:extraSequences
	if wwmt != undefined then (
		if saveToLib then (
			wwmt.saveProxy quiet:true

		)

		if isValidNode wwmt.target AND noVMF then (
			wwmt.target.exclude_vmf = true
		)

	)
	wwmt

)

